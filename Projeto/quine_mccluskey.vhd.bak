use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Entidade principal
entity quine_mccluskey is
    port (
        clk : in std_logic;
        reset : in std_logic;
        start : in std_logic;
        truth_table : in std_logic_vector(15 downto 0);
        done : out std_logic;
        -- Saída: até 8 termos, cada um com 8 bits (4 para number, 4 para dashes)
        result_terms : out std_logic_vector(63 downto 0);
        num_result_terms : out std_logic_vector(3 downto 0)
    );
end entity;

architecture behavioral of quine_mccluskey is

	 --Representação número binário
    type b_number_type is record
        number : std_logic_vector(3 downto 0);  -- 4 bits para ABCD
        dashes : std_logic_vector(3 downto 0);  -- 4 bits para don't cares
        used : std_logic;
    end record;
    
	 --Array de número binário, para agrupar nos grupos para fazer comparações
    type group_array is array (0 to 4) of b_number_type; -- máximo 5 grupos (0 a 4 uns)]
	 
	 --Relaçiona número binário com qual grupo ele pertence e qual a posição dele dentro desse grupo
    type table_type is array (0 to 4, 0 to 15) of b_number_type;
	 
	 --Serve para indicar quantos elementos existem em cada grupo
    type count_array is array (0 to 4) of integer range 0 to 16;
    
	 --Armazena os minitermos originas e quantos elementos tem em cada grupo
    signal original_table : table_type;
    signal original_count : count_array := (others => 0);
	 
	 --Armazena os termos da primeira iteração e quantos elementos tem em cada grupo
    signal p_group_table : table_type;
    signal p_group_count : count_array := (others => 0);
	 
	 --Armazena os termos da última iteração e quantos elementos tem e cada grupo	
    signal final_group_table : table_type;
    signal final_group_count : count_array := (others => 0);
    
    -- Define os 5 estados possíveis da máquina de estados
    type state_type is (IDLE, EXTRACT_MINTERMS, CREATE_P_GROUP, CREATE_FINAL_GROUP, OUTPUT_RESULT);
	 
	 --É o estado atual da máquina de estados, começa em IDLE
    signal current_state : state_type := IDLE;
    
    -- Sinais de trabalho
    signal processing_done : std_logic := '0';
    signal result_count : integer range 0 to 16 := 0;
    
    -- Função para contar os uns
    function count_ones(number : std_logic_vector(3 downto 0)) return integer is
        variable count : integer := 0;
    begin
        for i in number'range loop
            if number(i	) = '1' then
                count := count + 1;
            end if;
        end loop;
        return count;
    end function;
    
    -- Função para inicializar B_number (equivalente a init_B_number do C++)
    function init_b_number(n : std_logic_vector(3 downto 0); d : std_logic_vector(3 downto 0); u : std_logic) return b_number_type is
        variable result : b_number_type;
    begin
        result.number := n;
        result.dashes := d;
        result.used := u;
        return result;
    end function;

begin

    process(clk, reset)
        variable i, j, k : integer;
        variable temp_number, temp_dashes : std_logic_vector(3 downto 0);
        variable ones_count : integer;
        variable temp_b_number : b_number_type;
        variable mintermo_index : integer;
    begin
        if reset = '1' then
            current_state <= IDLE;
            processing_done <= '0';
            result_count <= 0;
            original_count <= (others => 0);
            p_group_count <= (others => 0);
            final_group_count <= (others => 0);
            done <= '0';
            
            -- Inicializar todas as tabelas
            for g in 0 to 4 loop
                for e in 0 to 15 loop
                    original_table(g, e) <= init_b_number("0000", "0000", '0');
                    p_group_table(g, e) <= init_b_number("0000", "0000", '0');
                    final_group_table(g, e) <= init_b_number("0000", "0000", '0');
                end loop;
            end loop;
            
        elsif rising_edge(clk) then
            
            case current_state is
                
                -- Estado IDLE: aguarda comando start
                when IDLE =>
                    if start = '1' then
                        current_state <= EXTRACT_MINTERMS;
                        done <= '0';
                    end if;
                
                -- Estado EXTRACT_MINTERMS: equivalente a create_table() do C++
                when EXTRACT_MINTERMS =>
                    
                    -- Reset counters
                    original_count <= (others => 0);
                    
                    -- Extrair mintermos da tabela verdade
                    for mintermo in 0 to 15 loop
                        if truth_table(mintermo) = '1' then
                            ones_count := count_ones(std_logic_vector(to_unsigned(mintermo, 4)));
                            
                            -- Adicionar ao grupo apropriado
                            temp_b_number := init_b_number(
                                std_logic_vector(to_unsigned(mintermo, 4)), 
                                "0000", 
                                '0'
                            );
                            
                            original_table(ones_count, original_count(ones_count)) <= temp_b_number;
                            original_count(ones_count) <= original_count(ones_count) + 1;
                        end if;
                    end loop;
                    
                    current_state <= CREATE_P_GROUP;
                
                -- Estado CREATE_P_GROUP: equivalente a create_p_group() do C++
                when CREATE_P_GROUP =>
                    
                    p_group_count <= (others => 0);
                    
                    -- Comparar grupos adjacentes
                    for group in 0 to 3 loop
                        
                        -- Para cada elemento do grupo atual
                        for elem1 in 0 to original_count(group)-1 loop
                            
                            -- Para cada elemento do próximo grupo
                            for elem2 in 0 to original_count(group+1)-1 loop
                                
                                -- Calcular AND e XOR (equivalente ao C++)
                                temp_number := original_table(group, elem1).number and 
                                             original_table(group+1, elem2).number;
                                temp_dashes := original_table(group, elem1).number xor 
                                             original_table(group+1, elem2).number;
                                
                                -- Verificar se diferem por apenas 1 bit
                                if count_ones(temp_dashes) = 1 then
                                    
                                    -- Marcar como usados
                                    original_table(group, elem1).used <= '1';
                                    original_table(group+1, elem2).used <= '1';
                                    
                                    -- Adicionar ao p_group
                                    ones_count := count_ones(temp_number);
                                    temp_b_number := init_b_number(temp_number, temp_dashes, '0');
                                    
                                    p_group_table(ones_count, p_group_count(ones_count)) <= temp_b_number;
                                    p_group_count(ones_count) <= p_group_count(ones_count) + 1;
                                    
                                end if;
                                
                            end loop;
                        end loop;
                    end loop;
                    
                    current_state <= CREATE_FINAL_GROUP;
                
                -- Estado CREATE_FINAL_GROUP: equivalente a create_final_group() do C++
                when CREATE_FINAL_GROUP =>
                    
                    final_group_count <= (others => 0);
                    
                    -- Comparar grupos adjacentes do p_group
                    for group in 0 to 3 loop
                        
                        for elem1 in 0 to p_group_count(group)-1 loop
                            
                            for elem2 in 0 to p_group_count(group+1)-1 loop
                                
                                -- Verificar se dashes são iguais (condição do C++)
                                if p_group_table(group, elem1).dashes = p_group_table(group+1, elem2).dashes then
                                    
                                    temp_number := p_group_table(group, elem1).number and 
                                                 p_group_table(group+1, elem2).number;
                                    temp_dashes := p_group_table(group, elem1).number xor 
                                                 p_group_table(group+1, elem2).number;
                                    
                                    if count_ones(temp_dashes) = 1 then
                                        -- XOR com dashes existentes (lógica do C++)
                                        temp_dashes := temp_dashes xor p_group_table(group, elem1).dashes;
                                        
                                        -- Marcar como usados
                                        p_group_table(group, elem1).used <= '1';
                                        p_group_table(group+1, elem2).used <= '1';
                                        
                                        -- Adicionar ao final_group
                                        ones_count := count_ones(temp_number);
                                        temp_b_number := init_b_number(temp_number, temp_dashes, '1');
                                        
                                        final_group_table(ones_count, final_group_count(ones_count)) <= temp_b_number;
                                        final_group_count(ones_count) <= final_group_count(ones_count) + 1;
                                        
                                    end if;
                                    
                                end if;
                                
                            end loop;
                        end loop;
                    end loop;
                    
                    current_state <= OUTPUT_RESULT;
                
                -- Estado OUTPUT_RESULT: equivalente a print_final_group() do C++
                when OUTPUT_RESULT =>
                    
                    result_count <= 0;
                    result_terms <= (others => '0');
                    
                    -- Coletar termos finais não usados
                    for group in 0 to 4 loop
                        for elem in 0 to final_group_count(group)-1 loop
                            if result_count < 8 then
                                -- Armazenar number e dashes no resultado
                                result_terms(result_count*8+7 downto result_count*8+4) <= final_group_table(group, elem).number;
                                result_terms(result_count*8+3 downto result_count*8) <= final_group_table(group, elem).dashes;
                                result_count <= result_count + 1;
                            end if;
                        end loop;
                    end loop;
                    
                    -- Coletar termos do p_group não usados
                    for group in 0 to 4 loop
                        for elem in 0 to p_group_count(group)-1 loop
                            if p_group_table(group, elem).used = '0' and result_count < 8 then
                                result_terms(result_count*8+7 downto result_count*8+4) <= p_group_table(group, elem).number;
                                result_terms(result_count*8+3 downto result_count*8) <= p_group_table(group, elem).dashes;
                                result_count <= result_count + 1;
                            end if;
                        end loop;
                    end loop;
                    
                    -- Coletar termos originais não usados
                    for group in 0 to 4 loop
                        for elem in 0 to original_count(group)-1 loop
                            if original_table(group, elem).used = '0' and result_count < 8 then
                                result_terms(result_count*8+7 downto result_count*8+4) <= original_table(group, elem).number;
                                result_terms(result_count*8+3 downto result_count*8) <= original_table(group, elem).dashes;
                                result_count <= result_count + 1;
                            end if;
                        end loop;
                    end loop;
                    
                    num_result_terms <= std_logic_vector(to_unsigned(result_count, 4));
                    done <= '1';
                    current_state <= IDLE;
                    
            end case;
            
        end if;
    end process;

end architecture;

-- Módulo de teste/demonstração
entity quine_mccluskey_testbench is
end entity;

architecture testbench of quine_mccluskey_testbench is
    
    component quine_mccluskey is
        port (
            clk : in std_logic;
            reset : in std_logic;
            start : in std_logic;
            truth_table : in std_logic_vector(15 downto 0);
            done : out std_logic;
            result_terms : out std_logic_vector(63 downto 0);
            num_result_terms : out std_logic_vector(3 downto 0)
        );
    end component;
    
    signal clk : std_logic := '0';
    signal reset : std_logic := '1';
    signal start : std_logic := '0';
    signal truth_table : std_logic_vector(15 downto 0);
    signal done : std_logic;
    signal result_terms : std_logic_vector(63 downto 0);
    signal num_result_terms : std_logic_vector(3 downto 0);
    
    constant clk_period : time := 10 ns;
    
begin
    
    -- Instanciar o módulo principal
    uut : quine_mccluskey_adapted
        port map (
            clk => clk,
            reset => reset,
            start => start,
            truth_table => truth_table,
            done => done,
            result_terms => result_terms,
            num_result_terms => num_result_terms
        );
    
    -- Gerador de clock
    clk_process : process
    begin
        clk <= '0';
        wait for clk_period/2;
        clk <= '1';
        wait for clk_period/2;
    end process;
    
    -- Processo de teste
    test_process : process
    begin
        -- Reset inicial
        reset <= '1';
        wait for 100 ns;
        reset <= '0';
        
        -- Exemplo: F(A,B,C,D) = Σ(1,3,7,11,15)
        -- Bits: 0000000010101000 (lido da direita para esquerda)
        truth_table <= "0000000010101000";
        
        -- Iniciar processamento
        wait for 50 ns;
        start <= '1';
        wait for 50 ns;
        start <= '0';
        
        -- Aguardar conclusão
        wait until done = '1';
        
        -- Resultado deve ser: A'B'D + CD
        -- Verificar resultado...
        
        wait for 500 ns;
        
        -- Outro teste: F(A,B,C,D) = Σ(0,2,8,10)
        reset <= '1';
        wait for 50 ns;
        reset <= '0';
        
        truth_table <= "0000010100000101";
        
        wait for 50 ns;
        start <= '1';
        wait for 50 ns;
        start <= '0';
        
        wait until done = '1';
        
        wait;
        
    end process;

end architecture;